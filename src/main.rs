pub mod lexer;
pub mod token;
// #[derive(Debug)]
// struct Bectangle {
//     width: u32,
//     height: u32,
// }

// enum IpAddrKind {
//     V4(String),
//     V6(String),
// }

// impl Bectangle {
//     fn area(&self) -> u32{
//         self.width * self.height
//     }
//     fn hold(&self, rect: &Bectangle) -> bool{
//        self.width >= rect.width && self.height >= rect.height
//     }
// }

// #[derive(Debug)]
// struct Rectangle {
//     width: u32,
//     height: u32,
// } 
// impl Rectangle {
//     fn area(&self) -> u32{
//         self.width * self.height
//     }
// }
fn main() {
    // let four = IpAddrKind::V4(String::from("BOB"));
    // let six = IpAddrKind::V6(String::from("GEORGE"));
    // let mut s = String::from("hello");
    // s.push_str(", world!");
    // println!("{}", s);
    // let x = String::from("Bob");
    // let x1 = x;
    // println!("Painc! at the Disco with {}", x1);
    // let x2 = x1.clone();
    // println!("WOW: {}", x2);
    // println!("{}",first_word(&String::from("BOBBY B")[..]));

    // let rect1 = Rectangle {width: 30, height: 50};    
    // println!("{:#?}", rect1);
    // println!("The are of the rectabgle is {:?} square pixels", rect1.area()); 
    // let ret1 = Bectangle { width: 10, height: 30};
    // let ret2 = Bectangle { width: 20, height: 30};
    // let ret3 = Bectangle { width: 10, height: 10};

    // println!("Can rect1 hold rect2? {}", ret1.hold(&ret2));
    // println!("Can rect1 hold rect3? {}", ret1.hold(&ret3));
    // route(six)
}


// fn first_word(s: &str) -> &str{
//     let bytes = s.as_bytes();

//     for (i, &item) in bytes.iter().enumerate() {
//         if item == b' ' {
//             return &s[0..i];
//         }
//     }
//     &s[..]

// }

// struct User {
//     username: String,
//     email: String,
//     sign_in_count: u64,
//     active: bool,
// }
// fn test() {
// let user1 = User {
//     email: String::from("someone@example.com"),
//     username: String::from("someusername123"),
//     active: true,
//     sign_in_count: 1,
// };
// }
// // user1.email = String::from("anotheremail@example.com");

// fn build_user(email: String, username: String) -> User {
//     User {
//         email,
//         username,
//         active: true,
//         sign_in_count: 1,
//     }
// }

// struct Color(i32, i32, i32);
// struct Point(i32, i32, i32);
// struct Bob {

// }

// fn  route(ip_kind: IpAddrKind) {

// }